/**-----------------------------------------------------------------------------------------
* Copyright Â© 2023 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the package root for more information
*-------------------------------------------------------------------------------------------*/
"use client";
import * as d from "react";
import e from "prop-types";
import { drawDOM as A, exportPDF as R } from "@progress/kendo-drawing";
import { saveAs as G } from "@progress/kendo-file-saver";
import * as H from "react-dom/server";
import { validatePackage as _ } from "@progress/kendo-react-common";
import * as W from "react-dom";
class $ extends d.Component {
  render() {
    return null;
  }
}
$.propTypes = {
  left: e.oneOfType([e.number, e.string]),
  top: e.oneOfType([e.number, e.string]),
  right: e.oneOfType([e.number, e.string]),
  bottom: e.oneOfType([e.number, e.string])
};
const x = ["bottom", "left", "right", "top"];
function D(r) {
  const t = d.Children.toArray(r.children).find((o) => o && o.type === $);
  return t ? z(t) : r.margin;
}
function z(r) {
  const t = {};
  for (let o = 0; o < x.length; o++) {
    const n = x[o], s = r.props[n];
    s !== void 0 && (t[n] = s);
  }
  return t;
}
const K = "export.pdf", Q = "KendoReact PDF Generator";
class j {
  constructor(t, o, n, s, i = {}) {
    this.drawDOM = t, this.exportPDF = o, this.saveAs = n, this.domElement = s, this.options = i, this.convertPageTemplateToHtml = (p) => `<span>${H.renderToStaticMarkup(
      d.createElement(this.options.pageTemplate, {
        pageNum: p.pageNum,
        totalPages: p.totalPages
      })
    )}</span>`;
  }
  savePDF(t) {
    const o = this.drawDOM(this.domElement, this.getDrawOptions()).then((n) => this.exportPDF(n, this.getPDFOptions())).then((n) => this.saveAs(n, this.options.fileName || K, this.getSaveOptions()));
    t && o.then(t, t);
  }
  getDrawOptions() {
    return {
      avoidLinks: this.options.avoidLinks,
      forcePageBreak: this.options.forcePageBreak,
      keepTogether: this.options.keepTogether,
      margin: this.options.margin,
      paperSize: this.options.paperSize,
      landscape: this.options.landscape,
      repeatHeaders: this.options.repeatHeaders,
      scale: this.options.scale,
      template: this.options.pageTemplate && this.convertPageTemplateToHtml
    };
  }
  getPDFOptions() {
    return {
      author: this.options.author,
      creator: this.options.creator || Q,
      date: this.options.date,
      imgDPI: this.options.imageResolution,
      keywords: this.options.keywords,
      landscape: this.options.landscape,
      margin: this.options.margin,
      multiPage: !0,
      paperSize: this.options.paperSize,
      producer: this.options.producer,
      subject: this.options.subject,
      title: this.options.title
    };
  }
  getSaveOptions() {
    return {
      forceProxy: this.options.forceProxy,
      proxyData: this.options.proxyData,
      proxyTarget: this.options.proxyTarget,
      proxyURL: this.options.proxyURL
    };
  }
}
const V = {
  name: "@progress/kendo-react-pdf",
  productName: "KendoReact",
  productCodes: ["KENDOUIREACT", "KENDOUICOMPLETE"],
  publishDate: 1702644853,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/components/my-license/"
};
class X extends d.Component {
  constructor(t) {
    super(t), this.rootElForPDF = null, _(V);
  }
  /**
   * @hidden
   */
  render() {
    return /* @__PURE__ */ d.createElement("div", { ref: (t) => {
      this.rootElForPDF = t;
    } }, this.props.children);
  }
  /**
   * Saves the content as a PDF file.
   *
   * @param callback - The callback to be executed after the PDF is saved.
   */
  save(t) {
    new j(
      A,
      R,
      G,
      this.rootElForPDF,
      this.getOptions()
    ).savePDF(t);
  }
  getOptions() {
    return Object.assign({}, this.props, { margin: D(this.props) });
  }
}
X.propTypes = {
  author: e.string,
  avoidLinks: e.oneOfType([e.bool, e.string]),
  forcePageBreak: e.string,
  keepTogether: e.string,
  creator: e.string,
  date: e.instanceOf(Date),
  imageResolution: e.number,
  fileName: e.string,
  forceProxy: e.bool,
  keywords: e.string,
  landscape: e.bool,
  margin: e.oneOfType([e.string, e.number, e.shape({
    left: e.oneOfType([e.number, e.string]),
    top: e.oneOfType([e.number, e.string]),
    right: e.oneOfType([e.number, e.string]),
    bottom: e.oneOfType([e.number, e.string])
  })]),
  pageTemplate: e.any,
  paperSize: e.any,
  repeatHeaders: e.bool,
  scale: e.number,
  proxyData: e.any,
  proxyURL: e.string,
  proxyTarget: e.string,
  producer: e.string,
  subject: e.string,
  title: e.string
};
function M(r, t = {}, o) {
  new j(
    A,
    R,
    G,
    r,
    t
  ).savePDF(o);
}
const P = {}, E = (r) => String(r).trim().split(" "), J = (r, t) => {
  const o = E(t);
  return !!E(r.className).find((n) => o.indexOf(n) >= 0);
}, u = (r) => (t) => J(t, r), I = (r) => (P[r] || (P[r] = (t) => String(t.nodeName).toLowerCase() === r.toLowerCase()), P[r]), c = (r, t, o = !0) => {
  if (r) {
    if (o && t(r))
      return r;
    for (r = r.firstChild; r; ) {
      if (r.nodeType === 1) {
        const n = c(r, t);
        if (n)
          return n;
      }
      r = r.nextSibling;
    }
  }
}, S = "k-grid-header", k = "k-grid-footer", Y = "TABLE", Z = I(Y), F = (r) => r ? "locked" : "wrap";
let ee = class {
  constructor(t) {
    this.element = t, this.list = c(t, u("k-grid-container"));
  }
  content(t) {
    return c(this.list, u(`k-grid-content${t ? "-locked" : ""}`));
  }
  header(t) {
    return this.headerWrap = this.headerWrap || c(this.element, u(S)), c(this.headerWrap, u(`${S}-${F(t)}`));
  }
  footer(t) {
    return this.footerWrap = this.footerWrap || c(this.element, u(k)), c(this.footerWrap, u(`${k}-${F(t)}`));
  }
  table() {
    return c(this.element, Z);
  }
};
const w = "k-first", te = "k-grid-header", re = "k-grid-footer", U = (r, t) => {
  const o = t.length;
  for (let n = 0; n < o; n++)
    r.appendChild(t[n].cloneNode(!0));
}, v = (r) => {
  const t = document.createElement("div");
  return t.className = "k-grid k-grid-md", t.appendChild(r), t;
}, O = (r) => {
  const t = r.length, o = r[0].cloneNode(!0), n = o.rows.length;
  if (t > 1)
    for (let s = 0; s < n; s++)
      for (let i = 1; i < t; i++)
        U(o.rows[s], r[i].rows[s].cells);
  return o;
}, oe = (r, t) => {
  if (t.length > 1 && r.rows.length > 1)
    for (let o = 1; o < r.rows.length; o++) {
      const n = t[0].rows[o].cells.length, s = r.rows[o].cells[n];
      String(s.className).indexOf(w) === -1 && (s.className += ` ${w}`);
    }
}, q = (r, t, o, n) => {
  const s = document.createElement("table"), i = r[0].cloneNode(!0);
  for (let a = 1; a < r.length; a++)
    U(i, r[a].querySelectorAll("col"));
  const p = O(t), l = O(o);
  if (p.className = te, oe(p, t), s.appendChild(i), s.appendChild(p), s.appendChild(l), n.length) {
    const a = O(n);
    a.className = re, s.appendChild(a);
  }
  return v(s);
}, ne = (r) => {
  const t = new ee(r), o = t.content();
  let n;
  if (o) {
    const s = [o.querySelector("colgroup")], i = [t.header().querySelector("thead")], p = [o.querySelector("tbody")], l = t.footer(), a = l ? [l.querySelector("tfoot")] : [];
    n = q(s, i, p, a);
  } else
    n = v(t.table().cloneNode(!0));
  return n;
};
function se(r) {
  return (t, o = {}, n, s, i) => ie(
    r,
    t,
    o,
    n,
    s,
    i
  );
}
function ie(r, t, o = {}, n, s, i) {
  let p, l, a;
  g();
  function g() {
    p = document.createElement("div"), p.setAttribute("style", "position:absolute; left: -5000px; top: 0px;"), l = document.createElement("div"), p.appendChild(l), document.body.appendChild(p), W.render(T(), l, f);
  }
  function f() {
    r(b(), o, y);
  }
  function y() {
    document.body.removeChild(p), document.body.removeChild(a), p = a = void 0, n && n();
  }
  function b() {
    a = document.createElement("div"), a.className = "k-grid-pdf-export-element";
    const h = ne(l);
    return a.appendChild(h), document.body.appendChild(a), h;
  }
  function T() {
    const h = s && { data: s, total: s.length, pageSize: s.length, skip: 0 }, C = { style: Object.assign({}, t.props.style, { width: "1000px" }) }, m = Object.assign({}, h, C);
    if (i && i.length > 0) {
      const B = ae(t);
      return d.cloneElement(t, m, i.concat(B));
    } else
      return d.cloneElement(t, m);
  }
}
function ae(r) {
  return d.Children.toArray(r.props.children).filter((t) => t && t.type && t.type.displayName !== "KendoReactGridColumn");
}
class pe extends d.Component {
  constructor(t) {
    super(t), this.saveGridPDF = se(this.getSavePDF());
  }
  /**
   * @hidden
   */
  render() {
    return null;
  }
  /* eslint-disable max-len */
  /**
   * Saves the content of the Grid as a PDF file.
   *
   * @param data - The data can be different from the currently displayed data in the Grid. Can be used to export all Grid pages.
   * @param callback - The callback that will be executed after the PDF is saved.
   */
  // tslint:enable:max-line-length
  save(t, o) {
    this.saveGridPDF(
      this.getGrid(),
      Object.assign({}, this.props, { margin: D(this.props) }),
      o,
      t,
      this.getCustomColumns()
    );
  }
  getSavePDF() {
    return M;
  }
  getGrid() {
    return d.Children.toArray(this.props.children).find((t) => t && t.type.displayName === "KendoReactGrid");
  }
  getCustomColumns() {
    return d.Children.toArray(this.props.children).filter((t) => t && t.type.displayName === "KendoReactGridColumn");
  }
}
pe.propTypes = {
  author: e.string,
  avoidLinks: e.oneOfType([e.bool, e.string]),
  forcePageBreak: e.string,
  keepTogether: e.string,
  creator: e.string,
  date: e.instanceOf(Date),
  imageResolution: e.number,
  fileName: e.string,
  forceProxy: e.bool,
  keywords: e.string,
  landscape: e.bool,
  margin: e.oneOfType([e.string, e.number, e.shape({
    left: e.oneOfType([e.number, e.string]),
    top: e.oneOfType([e.number, e.string]),
    right: e.oneOfType([e.number, e.string]),
    bottom: e.oneOfType([e.number, e.string])
  })]),
  pageTemplate: e.any,
  paperSize: e.any,
  repeatHeaders: e.bool,
  scale: e.number,
  proxyData: e.any,
  proxyURL: e.string,
  proxyTarget: e.string,
  producer: e.string,
  subject: e.string,
  title: e.string
};
const L = "k-grid-header", N = "k-grid-footer", le = "TABLE", ce = I(le);
class de {
  constructor(t) {
    this.element = t, this.list = c(t, u("k-grid"));
  }
  content() {
    return c(this.list, u("k-grid"));
  }
  header() {
    return this.headerWrap = this.headerWrap || c(this.element, u(L)), c(this.headerWrap, u(`${L}`));
  }
  footer() {
    return this.footerWrap = this.footerWrap || c(this.element, u(N)), c(this.footerWrap, u(`${N}`));
  }
  table() {
    return c(this.element, ce);
  }
}
const ue = (r) => {
  const t = new de(r), o = t.content();
  let n, s = t.header();
  if (s.childNodes.length > 1 && s.removeChild(s.childNodes[1]), s.childNodes[0].childNodes.forEach((i) => i.style.top = 0), o) {
    const i = [o.querySelector("colgroup")], p = [s], l = [o.querySelector("tbody")], a = t.footer(), g = a ? [a.querySelector("tfoot")] : [];
    n = q(i, p, l, g);
  } else
    n = v(t.table().cloneNode(!0));
  return n;
};
function he(r) {
  return (t, o = {}, n, s, i) => ge(
    r,
    t,
    o,
    n,
    s,
    i
  );
}
function ge(r, t, o = {}, n, s, i) {
  let p, l, a;
  g();
  function g() {
    p = document.createElement("div"), p.setAttribute("style", "position:absolute; left: -5000px; top: 0px;"), l = document.createElement("div"), p.appendChild(l), document.body.appendChild(p), W.render(T(), l, f);
  }
  function f() {
    r(b(), o, y);
  }
  function y() {
    document.body.removeChild(p), document.body.removeChild(a), p = a = void 0, n && n();
  }
  function b() {
    a = document.createElement("div"), a.className = "k-treelist-pdf-export-element";
    const h = ue(l);
    return a.appendChild(h), document.body.appendChild(a), a;
  }
  function T() {
    const h = o.allPages && s ? { data: s, take: Number.MAX_VALUE, skip: 0 } : {}, C = { style: Object.assign({}, t.props.style, { width: "1000px" }) }, m = Object.assign({}, h, C);
    return i && i.length > 0 ? d.cloneElement(t, Object.assign({}, m, { columns: i })) : d.cloneElement(t, m);
  }
}
class me extends d.Component {
  constructor(t) {
    super(t), this.saveTreeListPDF = he(this.getSavePDF());
  }
  /**
   * @hidden
   */
  render() {
    return null;
  }
  /* eslint-disable max-len */
  /**
   * Saves the content of the TreeList as a PDF file.
   *
   * @param data - The data that will be exported to the PDF. The data can be different from the currently displayed data in the TreeList.
   * @param columns - The columns that will be exported to the PDF. The columns collection can be different from the currently displayed in the TreeList.
   * @param callback - The callback that will be executed after the PDF is saved.
   */
  // tslint:enable:max-line-length
  save(t, o, n) {
    this.saveTreeListPDF(
      this.getTreeList(),
      Object.assign({}, this.props, { margin: D(this.props) }),
      n,
      t,
      o || []
    );
  }
  getSavePDF() {
    return M;
  }
  getTreeList() {
    const t = this.props.children;
    if (t && t.props.data && t.props.columns)
      return this.props.children;
  }
}
me.propTypes = {
  author: e.string,
  avoidLinks: e.oneOfType([e.bool, e.string]),
  forcePageBreak: e.string,
  keepTogether: e.string,
  creator: e.string,
  date: e.instanceOf(Date),
  imageResolution: e.number,
  fileName: e.string,
  forceProxy: e.bool,
  keywords: e.string,
  landscape: e.bool,
  margin: e.oneOfType([e.string, e.number, e.shape({
    left: e.oneOfType([e.number, e.string]),
    top: e.oneOfType([e.number, e.string]),
    right: e.oneOfType([e.number, e.string]),
    bottom: e.oneOfType([e.number, e.string])
  })]),
  pageTemplate: e.any,
  paperSize: e.any,
  repeatHeaders: e.bool,
  scale: e.number,
  proxyData: e.any,
  proxyURL: e.string,
  proxyTarget: e.string,
  producer: e.string,
  subject: e.string,
  title: e.string,
  allPages: e.bool
};
export {
  pe as GridPDFExport,
  j as KendoDrawingAdapter,
  X as PDFExport,
  $ as PDFMargin,
  me as TreeListPDFExport,
  D as getPageMargin,
  M as savePDF
};
